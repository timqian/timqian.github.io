<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Why writing things down</title>
      <link href="/2019/01/21/why-writing-things-down/"/>
      <url>/2019/01/21/why-writing-things-down/</url>
      
        <content type="html"><![CDATA[<ul><li>语言是目前为止我们最精确描述想法的方式</li><li>想法写下来的过程，是一个梳理，验证的过程。原来呆在脑子里信以为真的内容，经常比较混乱，甚至有没有意识到的逻辑漏洞。</li><li>想法没有记录下来，可能在脑袋里盘旋几分钟之后烟消云散，失去了与别的头脑相碰撞的机会。盘旋几分钟与得到碰撞的机会，是质的区别</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> thoughts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这样赌，一定赢？</title>
      <link href="/2015/05/05/%E8%BF%99%E6%A0%B7%E8%B5%8C%EF%BC%8C%E4%B8%80%E5%AE%9A%E8%B5%A2%EF%BC%9F/"/>
      <url>/2015/05/05/%E8%BF%99%E6%A0%B7%E8%B5%8C%EF%BC%8C%E4%B8%80%E5%AE%9A%E8%B5%A2%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="0-核心科技"><a href="#0-核心科技" class="headerlink" title="0. 核心科技"></a>0. 核心科技</h2><p>室友称自己掌握了赌博的核心科技(虽然目前应用地不是很顺利)。于夜深人静之时传授于我，陈述如下：</p><p><strong>记住！如果你第一次输了，第二次就将赌注加倍；如果第二次又输了，再将赌注加倍；…依次类推，不管赢的概率再小，照这种方式操作，只要你有足够多的钱，总会等到赢的那一次。然后，你就赚到了你想赢得钱！！！</strong><br>听起来好有道理！如果你已经忍不住想试一下，你可以去 <a href="http://caipiao.163.com/order/gxkuai3/#from=leftnav" target="_blank" rel="noopener">网易彩票 - 新快3</a> 猜数字。合法赌博！</p><p>不过，这种方法是否真的像看上去那么有效？还是先拿 <em>概率论</em> 来学以致用一下，毕竟关系到RMB啊。。</p><h2 id="1-貌似挺对"><a href="#1-貌似挺对" class="headerlink" title="1. 貌似挺对"></a>1. 貌似挺对</h2><p>假设赌博胜负的概率<em>真的是</em>随机的，每一次赢的概率为 $$p$$。我们一共进行n次赌博。那么，<br>在第一次赢的概率就是： $$p$$；<br>在第二次赢的概率是： $$(1-p)p$$（条件概率，还记得吧）；<br>在第三次：$$(1-p)^2p$$；<br>…<br>在第n次：$$(1-p)^{n-1} p$$。</p><p>下图说明了当$$p=0.4$$时，在第n次获胜的概率：</p><center><br>    <span>在第n次获胜的概率</span><br>    <canvas id="canvas" height="300" width="700"></canvas><br></center><p>利用等比数列前n项和公式可得，在前n次赢的概率是：</p><p>$$P_n = p + (1-p)p + (1-p)^2 p + \dots + (1-p)^{n-1} p = 1-(1-p)^n $$ </p><p>容易证明：</p><p>$$<br>\lim_{n \to \infty} P_n = 1<br>$$</p><p>也就是说，如果你不差钱，利用刚刚的规则，的确，总有一天会赢的。来看看当 $$p=0.4$$时，在<strong>前</strong>n次获胜的概率：</p><center><br>    <span>在<b>前</b>n次获胜的概率</span><br>    <canvas id="canvas2" height="300" width="700"></canvas><br></center><p>然而现实生活总是差钱的，看看这种策略是怎么花钱的应该不是坏事。</p><h2 id="2-考虑成本"><a href="#2-考虑成本" class="headerlink" title="2. 考虑成本"></a>2. 考虑成本</h2><p>假设我们的目标收益是 1 元，在第n次下注时我们所投入的总资金：</p><p>第一次：1元<br>第二次：2元<br>第三次：4元<br>第四次：8元<br>…<br>第n次：$$2^{n-1}$$ 元<br>总投入：$$M = 1 + 2^1 + 2^2 + \dots + 2^{n-1}$$ 元</p><p>来看一下 $$M, n$$ 的关系：</p><center><br>    <span>在<b>前</b>n次的总投入M</span><br>    <canvas id="canvas3" height="300" width="700"></canvas><br></center><p>在真实生活中，我们可以输掉的钱是有限的（从图中可以看出，如果第35次还没赢，需要投入350亿元，不是马云的儿子，敢玩？）。</p><p>由于资金的限制，导致我们无法玩无穷多次，于是，我们就有可能会输了（很遗憾）。可以来计算一下，当我们有一定的预算（$$M$$）时，期望收益($$E$$)是多少。但是要怎么计算期望呢？先来看一个例子：<br>假设预算是$$3$$元，那么，最多可以赌两次。于是赢的概率是 $$P_{win} = 1 - (1-p)^1$$；期望收益可以用下式表示：</p><p>$$<br>E = p_{win} \times 1 - (1-p_{win}) \times 3<br>$$</p><p>按照这样的方法，我们可以计算出不同预算对应的期望收益。</p><p>还是以$$p=0.4$$为例，期望与预算的关系如图所示，为方便起见，这里的预算取为作n次总投资所需要的资金：</p><center><br>    <span>期望收益与预算的关系</span><br>    <canvas id="canvas4" height="300" width="700"></canvas><br>    <small>预算</small><br></center><p>看到这张图，我好像明白了什么，，你呢 SiPu You？</p><script src="http://cdn.bootcss.com/Chart.js/1.0.2/Chart.js"></script><script src="http://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script type="text/javascript">    var p = 0.4; //winning probability    var n = 35;  //trial #    var x_axis = []; //x 轴    var Pn = [];  //在第n次内中奖的概率    var P = 0; //temp    var PPn = [];  //前n次内中奖的概率    var PP = 0;    var Mn = []; //n次总投资数组    var M = 0; //temp    var En = []; //第n次投资的期望收益    var E = 0; //temp    for(var i=1; i<=n; i++){        x_axis.push("前" + i + "次");        P = Math.pow(1-p, i-1) * p;        Pn.push(P);        PP = 1 - Math.pow(1-p, i);        PPn.push(PP);        M += Math.pow(2, i-1);        Mn.push(M);        E = 1 * PP - (1 - PP) * M;        En.push(E);    }    var lineChartData = {        labels : x_axis,        datasets : [            {                label: "1",                fillColor : "rgba(151,187,205,0.2)",                strokeColor : "rgba(151,187,205,1)",                pointColor : "rgba(151,187,205,1)",                pointStrokeColor : "#fff",                pointHighlightFill : "#fff",                pointHighlightStroke : "rgba(151,187,205,1)",                data : Pn            }        ]    }    var lineChartData2 = {        labels : x_axis,        datasets : [            {                label: "2",                fillColor : "rgba(151,187,205,0.2)",                strokeColor : "rgba(151,187,205,1)",                pointColor : "rgba(151,187,205,1)",                pointStrokeColor : "#fff",                pointHighlightFill : "#fff",                pointHighlightStroke : "rgba(151,187,205,1)",                data : PPn            }        ]    }    var lineChartData3 = {        labels : x_axis,        datasets : [            {                label: "3",                fillColor : "rgba(151,187,205,0.2)",                strokeColor : "rgba(151,187,205,1)",                pointColor : "rgba(151,187,205,1)",                pointStrokeColor : "#fff",                pointHighlightFill : "#fff",                pointHighlightStroke : "rgba(151,187,205,1)",                data : Mn            }        ]    }    var lineChartData4 = {        labels : Mn.map(function(elem){return elem + '元'}),        datasets : [            {                label: "4",                fillColor : "rgba(151,187,205,0.2)",                strokeColor : "rgba(151,187,205,1)",                pointColor : "rgba(151,187,205,1)",                pointStrokeColor : "#fff",                pointHighlightFill : "#fff",                pointHighlightStroke : "rgba(151,187,205,1)",                data : En            }        ]    }window.onload = function(){    var ctx = document.getElementById("canvas").getContext("2d");    window.myLine = new Chart(ctx).Line(lineChartData);    var ctx2 = document.getElementById("canvas2").getContext("2d");    window.myLine2 = new Chart(ctx2).Line(lineChartData2);            var ctx3 = document.getElementById("canvas3").getContext("2d");    window.myLine3 = new Chart(ctx3).Line(lineChartData3);        var ctx4 = document.getElementById("canvas4").getContext("2d");    window.myLine4 = new Chart(ctx4).Line(lineChartData4);    }</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>]]></content>
      
      
      
        <tags>
            
            <tag> tech </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从哈密顿量出发，理解多电子原子的“轨道模型”和它的磁矩(密度泛函理论)</title>
      <link href="/2015/03/12/dft-matlab/"/>
      <url>/2015/03/12/dft-matlab/</url>
      
        <content type="html"><![CDATA[<h1 id="基于密度泛函理论-DFT-，使用matlab求解原子状态"><a href="#基于密度泛函理论-DFT-，使用matlab求解原子状态" class="headerlink" title="基于密度泛函理论(DFT)，使用matlab求解原子状态"></a>基于密度泛函理论(DFT)，使用matlab求解原子状态</h1><ul><li>使用自洽场方法求解 Kohn-Sham 方程</li></ul><h2 id="一-DFT简述（使用Atomic-units）"><a href="#一-DFT简述（使用Atomic-units）" class="headerlink" title="一. DFT简述（使用Atomic units）"></a>一. DFT简述（使用Atomic units）</h2><p>密度泛函理论主要由 Kohn 和沈吕九在半个世纪之前创造。用于求解多电子体系基态性质，其主要思想是这样的：</p><p><strong>首先</strong>：假设一组波函数 $${\psi_i(\vec x)}$$ 描述了电子们的状态</p><p><strong>然后</strong>：由 $${\psi_i(\vec x)}$$ 导出体系能量的表达式(包含电子动能，库伦能等)：</p><ol><li>电子动能：$$ T_{el} = -\frac{1}{2} \sum_{i=1}^{n}  \int \psi_i^*(\vec x) \nabla^2 \psi_i(\vec x) d^3x $$</li><li>电子与原子之间相互作用能： $$ V_{ext} = \int n(\vec x) V_{nuc}(\vec x) d^3x $$</li><li>电子受其他电子的库伦能：$$V_H = \frac{1}{2} \int \phi(\vec x) n(\vec x) d^3x $$，其中$$\phi(\vec x)$$ 为电子电荷密度形成的库伦式，可以通过求解 Poisson 方程（$$ \nabla^2 \phi = - 4 \pi n$$）得到 </li><li>对库伦能的修正（交换能）：$$E_{x} = \int f_x(n(\vec x)) dV  $$</li></ol><p><em>注</em>：<br>其中：$$n(\vec x) = \sum_i  \psi_i^* \psi_i  $$ 为电子密度；<br>对于交换能$$E_{x} $$，有各种近似方法，这里使用最简单的局域密度近似。具体介绍可以在<a href="http://en.wikipedia.org/wiki/Local-density_approximation" target="_blank" rel="noopener">这里找到</a>。</p><blockquote><p>寻找更好的交换能函数，是凝聚态中一个十分重要的研究课题。</p></blockquote><p>综上，可以得到总能量表达式为：</p><p>$$E[{ \psi_i(x)}] = T_{el} + V_{ext} + V_H + E_{x}$$</p><p><strong>最后</strong>：利用变分法，求解使体系能量最小时波函数需要满足的条件，就可以得到著名的Kohn-Sham 方程：</p><p>$$<br>    \left[ -\frac{\hbar^2}{2m} \nabla^2 + V_{ext}(\vec x) + \phi(\vec x) + V_{x}(\vec x) \right] \psi_i(\vec x) = \epsilon_i \psi(\vec x)<br>$$</p><p>其中$$V_{x}$$ 为交换势, 具体表达式见<a href="http://en.wikipedia.org/wiki/Local-density_approximation" target="_blank" rel="noopener">这里（局域密度近似）</a></p><p>令人吃惊的是，它与单电子 Schrodinger 方程是如此的相似。不同之处只是在于，由于电子之间相互作用，Hamiltonian 中的势能项包含了电子密度。这使得K-S方程成为一个非线性方程（哈密顿量与波函数有关），与我们熟知的本征值问题不太一样。接下来，介绍如何编程解这个方程。</p><h2 id="二-求解-Kohn-Sham-方程的自洽场-self-consistent-field-method-SCF-算法"><a href="#二-求解-Kohn-Sham-方程的自洽场-self-consistent-field-method-SCF-算法" class="headerlink" title="二. 求解 Kohn-Sham 方程的自洽场(self-consistent field method SCF)算法"></a>二. 求解 Kohn-Sham 方程的自洽场(self-consistent field method SCF)算法</h2><p><strong>Initialization</strong>: </p><ol><li>确定电子个数（N）</li><li>用外势能近似总势能，即 $$V_{tot} = V_{ext}$$，得到近似Hamiltonian；<br><strong>Iteration</strong>：</li><li>求Hamiltonian最小的 N/2 个本征值，及对应的本征函数 $$\psi_i(\vec x)$$（每个态上占据两个电子）</li><li>由得到的本征函数集 $${\psi_i(\vec x)}$$ 求交换势（$$\phi(\vec x)$$）和库伦势（$$V_{x}(\vec x)$$）</li><li>更新Hamiltonian: $$H = -\frac{\hbar^2}{2m} \nabla^2 + V_{ext}(\vec x) + \phi(\vec x) + V_{x}(\vec x)$$</li><li>判断当前结果是否满足要求，如果满足，就跳出循环</li></ol><h2 id="三-算法的-Matlab-实现"><a href="#三-算法的-Matlab-实现" class="headerlink" title="三. 算法的 Matlab 实现"></a>三. 算法的 Matlab 实现</h2><p>使用条件及近似方式：</p><blockquote><p>只考虑电子成对占据某一能态的原子；<br>使用<a href="http://en.wikipedia.org/wiki/Local-density_approximation" target="_blank" rel="noopener">LDA近似</a>；<br>使用空间离散化的方法求解Hamiltonian的本征值；<br>使用<a href="http://en.wikipedia.org/wiki/Dirichlet_boundary_condition" target="_blank" rel="noopener">Dirichlet边界条件</a>（边界处概率密度为0）；<br>以4个电子为例。</p></blockquote><p>主程序：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%For double occupation</span></span><br><span class="line">N = <span class="number">4</span>;  <span class="comment">% num of enectrons</span></span><br><span class="line">g = <span class="number">50</span>  <span class="comment">% num of lattices</span></span><br><span class="line">g3 = g^<span class="number">3</span>;</span><br><span class="line">p = <span class="built_in">linspace</span>(<span class="number">-5</span>, <span class="number">5</span>, g);         <span class="comment">% one dimensiton space lattice</span></span><br><span class="line">[X, Y, Z] = <span class="built_in">meshgrid</span>(p, p, p);  <span class="comment">% three dimension space lattice</span></span><br><span class="line">h = p(<span class="number">2</span>) - p(<span class="number">1</span>);                <span class="comment">% latice spacing</span></span><br><span class="line">X = X(:); Y = Y(:); Z = Z(:);   <span class="comment">% all elements of arraty as a single column</span></span><br><span class="line">R = <span class="built_in">sqrt</span>(X.^<span class="number">2</span> + Y.^<span class="number">2</span> + Z.^<span class="number">2</span>);   <span class="comment">% distance from the center</span></span><br><span class="line">Vext = -N ./ R;                 <span class="comment">% potential energy(2 protons)</span></span><br><span class="line">e = <span class="built_in">ones</span>(g,<span class="number">1</span>);               </span><br><span class="line">L = spdiags([e <span class="number">-2</span>*e e], <span class="number">-1</span>:<span class="number">1</span>, g, g) / h^<span class="number">2</span>; <span class="comment">% 1D finite difference Laplacian (with 0 boundary condition)</span></span><br><span class="line">I = speye(g);</span><br><span class="line">L3 = kron(kron(L,I), I) + kron(kron(I, L), I) + kron(kron(I, I), L);  <span class="comment">% extend Laplacian to 3 D</span></span><br><span class="line">Vtot = Vext;  <span class="comment">%initial guess</span></span><br><span class="line">ncomp = <span class="built_in">exp</span>(-R.^<span class="number">2</span>/<span class="number">2</span>);  <span class="comment">%compensation charge(for poisson equation)</span></span><br><span class="line">ncomp = -N * ncomp / sum(ncomp) / h^<span class="number">3</span>;</span><br><span class="line">ncomppot = -N./R.*<span class="built_in">erf</span>(R/<span class="built_in">sqrt</span>(<span class="number">2</span>));   <span class="comment">%solution of poisson eq. of compensation charge</span></span><br><span class="line"><span class="comment">%%%%%%%%initial guess for N = 4%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line">E = [ <span class="number">-4</span> <span class="number">-1</span> ];</span><br><span class="line">PSI = [ <span class="built_in">exp</span>(<span class="number">-3.7</span>*R) <span class="built_in">exp</span>(<span class="number">-0.17</span>*R) ];</span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="keyword">for</span> iter = <span class="number">1</span>:<span class="number">5</span> <span class="comment">%Do the main loop not for ever</span></span><br><span class="line">  H = <span class="number">-0.5</span> * L3 + spdiags(Vtot, <span class="number">0</span>, g3, g3);  <span class="comment">% Hamiltonian of Helium</span></span><br><span class="line">  [PSI, E] = lowestNEigen(H, PSI, E, N, <span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:(N/<span class="number">2</span>)</span><br><span class="line">    PSI(:,<span class="built_in">i</span>) = PSI(:,<span class="built_in">i</span>) / norm(PSI(:,<span class="built_in">i</span>));</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  PSI = PSI / h^(<span class="number">3</span>/<span class="number">2</span>);   <span class="comment">%normalize PSI</span></span><br><span class="line"></span><br><span class="line">  n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:(N/<span class="number">2</span>) <span class="comment">%calculate density of electron</span></span><br><span class="line">    n = n + <span class="number">2</span>*PSI(:,<span class="built_in">i</span>).^<span class="number">2</span>;  </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  Vx = -(<span class="number">3</span>/<span class="built_in">pi</span>)^(<span class="number">1</span>/<span class="number">3</span>)*n.^(<span class="number">1</span>/<span class="number">3</span>);  <span class="comment">%exchange potantial (LDA)</span></span><br><span class="line">  Vh = cgs(L3, <span class="number">-4</span>*<span class="built_in">pi</span>*(n + ncomp), <span class="number">1e-7</span>, <span class="number">400</span>) - ncomppot; <span class="comment">%Hartree potantial(solution of poisson eq.: L3 Vh = -4*pi*n)</span></span><br><span class="line">  Vtot = Vx + Vh + Vext;  <span class="comment">%total potantial</span></span><br><span class="line">  </span><br><span class="line">  T = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:(N/<span class="number">2</span>)  <span class="comment">%calculate Kinetic energy</span></span><br><span class="line">    T = T + <span class="number">2</span>*PSI(:,<span class="built_in">i</span>)'*(<span class="number">-0.5</span>*L3)*PSI(:,<span class="built_in">i</span>) * h^<span class="number">3</span>;  <span class="comment">%Kinetic enerty(expactation value of Kinetic energy oprator)</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  Eext = sum(n.*Vext) * h^<span class="number">3</span>;  <span class="comment">%external energy</span></span><br><span class="line">  Eh = <span class="number">0.5</span> * sum(n.*Vh) * h^<span class="number">3</span>;  <span class="comment">%hartree energy</span></span><br><span class="line">  Ex = sum(n.*Vx * (<span class="number">3</span>/<span class="number">4</span>)) * h^<span class="number">3</span>;   <span class="comment">%How come the 3/4????????????????</span></span><br><span class="line">  Etot = T + Eext + Eh + Ex;</span><br><span class="line">  more off;   <span class="comment">%see the disp  in the loop, but why?</span></span><br><span class="line">  E</span><br><span class="line"><span class="comment">%  disp(['Kinetic energy ' num2str(T,5) ]);</span></span><br><span class="line"><span class="comment">%  disp(['Exchange energy ' num2str(Ex,5) ]);</span></span><br><span class="line"><span class="comment">%  disp(['External energy ' num2str(Eext,5) ]);</span></span><br><span class="line"><span class="comment">%  disp(['Potential energy ' num2str(Eh,5) ]);</span></span><br><span class="line"> <span class="built_in">disp</span>([<span class="string">'Total energy'</span> num2str(Etot,<span class="number">5</span>) ]);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%scatter3(X(1:10:g3),Y(1:10:g3),Z(1:10:g3),n(1:10:g3)*1000);</span></span><br><span class="line">scatter3(X,Y,Z,n*4);  //show electron density</span><br></pre></td></tr></table></figure><p>用Davidson method 求解本征值和本征向量：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%  Usage: Get lowest eigenvalue and cooresponding Evetor by Davidson's method</span></span><br><span class="line"><span class="comment">%  H: discrete Hamiltonian</span></span><br><span class="line"><span class="comment">%  PSI, E： initial guess of eigenvectors and eigenvalue</span></span><br><span class="line"><span class="comment">%  N: number of eigen pair needed</span></span><br><span class="line"><span class="comment">%  iter: iteration number</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[PSI, E]</span> = <span class="title">lowestNEigen</span><span class="params">(H, PSI, E, N, iter)</span></span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:iter  <span class="comment">%"for loop": for faster convergent</span></span><br><span class="line">  RR = H*PSI - PSI*<span class="built_in">diag</span>(E);  <span class="comment">%All the Residual vectors at once</span></span><br><span class="line">  PSIe = [ PSI RR ];  <span class="comment">%Subsbace</span></span><br><span class="line">  HH = PSIe' * H * PSIe;  <span class="comment">%For transform subspace to a space inwhich H is diagnolized</span></span><br><span class="line">  SS = PSIe' * PSIe;  <span class="comment">%For transform subspace to a space inwhich H is diagnolized</span></span><br><span class="line">  HH = HH + HH';</span><br><span class="line">  SS = SS + SS';  <span class="comment">%Ensure they are Hermition matrix, so that the eigen value will return in order      </span></span><br><span class="line">  [U, E] = eig(HH,SS);<span class="comment">%For transform subspace to a space inwhich H is diagnolized</span></span><br><span class="line">  E = <span class="built_in">diag</span>(E);  <span class="comment">%Diagnal Matix to vector</span></span><br><span class="line">  PSIe = PSIe * U;</span><br><span class="line">  <span class="comment">%%SIe' * H * PSIe</span></span><br><span class="line">  PSI = PSI(:,<span class="number">1</span>:(N/<span class="number">2</span>));</span><br><span class="line">  E = E(<span class="number">1</span>:(N/<span class="number">2</span>)); <span class="comment">%Pick lowest N/2 eigen vectors and values</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>Total energy: -10.793</p><p>电子密度分布图：<img src="\public\blogfigure\4electron.png" alt="电子密度"></p><h2 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来</h2><p>误差较大，如何升级？</p><p>如何在 DFT 中考虑空间角动量，自旋角动量，由此研究其磁性？</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://www.youtube.com/watch?v=bW44gCulrvI" target="_blank" rel="noopener">1h DFT code in matlab</a></p><p><a href="http://en.wikipedia.org/wiki/Kronecker_sum_of_discrete_Laplacians" target="_blank" rel="noopener">Laplace 算子的离散化方法及离散空间中的分离变量法</a></p><p><a href="http://web.mit.edu/bolin/www/Project-Report-18.335J.pdf" target="_blank" rel="noopener">快速求解矩阵最小（或最大）本征值本征向量的Davidson method</a></p><p><a href="http://en.wikipedia.org/wiki/Poisson&#39;s_equation#Potential_of_a_Gaussian_charge_density" target="_blank" rel="noopener">Gaussian compensation charge</a></p><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>]]></content>
      
      
      
        <tags>
            
            <tag> physics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solving Hydrogen atom numerically with 14 lines of Matlab code</title>
      <link href="/2015/03/04/H-atom-numerical/"/>
      <url>/2015/03/04/H-atom-numerical/</url>
      
        <content type="html"><![CDATA[<p>Let’s have a look the code first(They were wrote by Mikael Kuisma in <a href="https://www.youtube.com/watch?v=bW44gCulrvI" target="_blank" rel="noopener">this vedio</a>):</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">g = <span class="number">40</span>; g3 = g^<span class="number">3</span>;</span><br><span class="line">p = <span class="built_in">linspace</span>(<span class="number">-4</span>, <span class="number">4</span>, g);         <span class="comment">% one dimensiton space lattice</span></span><br><span class="line">[X, Y, Z] = <span class="built_in">meshgrid</span>(p, p, p);  <span class="comment">% three dimension space lattice</span></span><br><span class="line">h = p(<span class="number">2</span>) - p(<span class="number">1</span>);                <span class="comment">% latice spacing</span></span><br><span class="line">X = X(:); Y = Y(:); Z = Z(:);   <span class="comment">% all elements of arraty as a single column</span></span><br><span class="line">R = <span class="built_in">sqrt</span>(X.^<span class="number">2</span> + Y.^<span class="number">2</span> + Z.^<span class="number">2</span>);   <span class="comment">% distance from the center</span></span><br><span class="line">Vext = <span class="number">-1</span> ./ R;                 <span class="comment">% potential energy</span></span><br><span class="line">e = <span class="built_in">ones</span>(g,<span class="number">1</span>);               </span><br><span class="line">L = spdiags([e <span class="number">-2</span>*e e], <span class="number">-1</span>:<span class="number">1</span>, g, g) / h^<span class="number">2</span>; <span class="comment">% 1D finite difference Laplacian</span></span><br><span class="line">I = speye(g);</span><br><span class="line">L3 = kron(kron(L,I), I) + kron(kron(I, L), I) + kron(kron(I, I), L);  <span class="comment">% extend Laplacian to 3 D</span></span><br><span class="line">H = <span class="number">-0.5</span> * L3 + spdiags(Vext, <span class="number">0</span>, g3, g3);  <span class="comment">% Hamiltonian of H atom</span></span><br><span class="line">[PSI,E] = eigs(H, <span class="number">1</span>, <span class="string">'sa'</span>);                      <span class="comment">% Smallest eigenvalue of H</span></span><br><span class="line"><span class="comment">%disp(['Total energy for Hydrogen atom' num2str(E*27.21, 5) 'eV']); %display result</span></span><br><span class="line"><span class="comment">%PSI_3 = reshape(PSI, [g,g,g]);</span></span><br><span class="line"><span class="built_in">scatter3</span>(X,Y,Z,PSI.^<span class="number">2</span> *<span class="number">9000</span>);</span><br></pre></td></tr></table></figure><p>These code calculated the  ground state energy of Hydrogen atom(You can run the code online in <a href="http://www.tutorialspoint.com/matlab/try_matlab.php" target="_blank" rel="noopener">this website</a>).</p><p>Result: <img src="/public/blogfigure/Hydrogen_lowest.png" alt="Electron density"></p><p>Energy: 13.321eV</p><h2 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h2><p>The Hamiltonian of electron in the Hydrogen is (in <a href="http://en.wikipedia.org/wiki/Atomic_units" target="_blank" rel="noopener">Atomic units</a>):</p><p>$$<br>H =  -\frac{1}{2} \nabla^2 - \frac{1}{r}<br>$$</p><p>In order to calculate the energy levels and wave functions of Hydrogen, we have to solve the t-independent Schrodinger equation of the electron in a Hydrogen atom is</p><p>$$<br> H \psi_n = E_n \psi_n<br>$$</p><p>Generally speaking, $$H$$ is an Oprator, $$E_n$$ is its eigenvalues and $$\psi_n$$ is the corresponding eigenvactors.<br>In continus space, the Hamiltonian is complicated as it contains second derivatives(the Laplacian: $$\nabla^2$$). </p><p>However, if we discretize the space, the wave function becomes a column vector, and the Hamiltonian can be expresse’d as<br>a matrix. As it is an opration on the vector.<br>In this way, the problem is transformed to “find eigenvactors and eigenvalues of a matrix”. And matlab is an expert about this kind of job.</p><p>In order to get this matrix form of $$H$$, the hard part is to the Laplacian. And <a href="http://en.wikipedia.org/wiki/Kronecker_sum_of_discrete_Laplacians" target="_blank" rel="noopener">this link</a><br>tells you how to get the “discrete Laplacians”.</p><h2 id="Code-explanation"><a href="#Code-explanation" class="headerlink" title="Code explanation"></a>Code explanation</h2><p>Comment by the code owner:</p><pre><code>There is a special trick with the grids. We take a 3d grid with dimensions g times g times g. We flatten the 3d-array to a vector of dimensions 1 x g^3. The hamiltonian operator is a linear mapping in this vector space, thus a g^3 x g^3 array. After we have calculated the wave function, we can reshape it back from vector representation to 3    --[Mikael Kuisma](https://www.youtube.com/channel/UCmRLy_j4kXTktxLPY9QtHbw)</code></pre><p>List of Matlab functions used in the code.</p><ul><li>y = linspace(x1,x2,N) returns N linearly spaced points.</li><li>[X,Y,Z] = meshgrid(xgv,ygv,zgv) produces three-dimensional coordinate arrays. The output coordinate arrays X, Y, and Z contain copies of the grid vectors xgv, ygv, and zgv respectively. The sizes of the output arrays are determined by the length of the grid vectors. For grid vectors xgv, ygv, and zgv of length M, N, and P respectively, X, Y, and Z will have N rows, M columns, and P pages.</li><li>A = spdiags(B,d,m,n) creates an m-by-n sparse matrix by taking the columns of B and placing them along the diagonals specified by d.</li><li>S = speye(m,n) and S = speye([m n]) form an m-by-n sparse matrix with 1s on the main diagonal.</li><li>K = kron(A,B) returns the Kronecker tensor product of matrices A and B. If A is an m-by-n matrix and B is a p-by-q matrix, then kron(A,B) is an m<em>p-by-n</em>q matrix formed by taking all possible products between the elements of A and the matrix B.</li><li>eigs(A,k,sigma) and eigs(A,B,k,sigma) return k eigenvalues based on sigma, which can take any of the following values… where ‘sa’ means smallest</li><li>disp(X) displays the contents of X without printing the variable name. disp does not display empty variables.</li></ul><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>]]></content>
      
      
      
        <tags>
            
            <tag> physics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>近自由电子模型与紧束缚模型--两种近似方式</title>
      <link href="/2015/03/03/near-free-and-tight-binding/"/>
      <url>/2015/03/03/near-free-and-tight-binding/</url>
      
        <content type="html"><![CDATA[<p>近自由电子模型和紧束缚模型是能带理论最基础的内容。二者以不同的近似方式解释了固体能带的成因。</p><h2 id="共同之处"><a href="#共同之处" class="headerlink" title="共同之处"></a>共同之处</h2><ol><li>均为绝热近似（简单讲就是：研究电子性质时忽略离子实的运动）</li><li>均为单电子近似（不考虑电子间相互作用，只考虑单个电子在周期势中的性质。解出体系的能级结构，然后把所有电子填进去）</li><li>均用到周期性边界条件（不太确定是否一定需要，”但Brillouin区内波矢k可以取值的数目等于晶体元胞数”这一结论似乎只能有它得到吧？not sure）</li><li>均用到Bloch定理（将电子所处的晶格体系看作周期性势场，体系哈密顿量具有平移不变性，这使得电子的波函数满足一定的形式$$\psi_k(r) = e^{ikr} u_{k,j}(r)$$。（其中$$u_{k,j}$$具有于与晶格一样的周期性，k指上条说到的波失，j指的是电子所处的能带，一对k，j指代了一个波函数</li></ol><h2 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h2><p>近自由电子模型是对离子实的势做近似，假设势十分弱。经计算可发现，在这种情况下，势只对处于Brillouin区边界处的电子（k靠近Brillouin区）<br>产生影响，导致能级发生分裂。而非边界处的电子能级则与自由电子一样。</p><p>紧束缚近似则是对电子的波函数做近似，假设原子最电子的束缚十分强，orbital态仍然保持不变，只是电子可以在相邻原子间跳转。这样，单电子所处的状态<br>就是一种各种orbital的叠加态。又由于外势的周期性，电子满足Bloch定理，由此可以构造出电子所处的状态了：</p><p>$$<br>\psi_k(r) = \sum_T e^{ikT} \phi(r-T)<br>$$</p><p>其中$$k$$代表Bloch波失，取值范围是倒空间Brillouin区中的离散位置。 $$\phi(r-T)$$ 代表位于 $$T$$ 位置的原子orbital。</p><p>有了电子的状态，再根据这个状态和Schrodinger方程，经过一些计算就可以得到不同$$k$$ 态对应的能级了。</p><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>]]></content>
      
      
      
        <tags>
            
            <tag> physics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从哈密顿量出发，理解多电子原子的“轨道模型”和它的磁矩</title>
      <link href="/2015/01/24/atom_magnetic_moment_perturbation/"/>
      <url>/2015/01/24/atom_magnetic_moment_perturbation/</url>
      
        <content type="html"><![CDATA[<blockquote><p>（字太多！讲要点就好了！逻辑关系）由原子的哈密顿量出发，经过近似和微扰，得到“原子轨道模型”</p></blockquote><p>若仅考虑库伦相互作用，拥有N个电子的原子的哈密顿量可以这样表示：</p><p>$$<br>H = \sum_{i=1}^N \left[ -\frac{1}{2} \nabla_i^2 - \frac{Z}{r_i} \right] + \sum_{i&gt;j} \frac{1}{ r_{ij} }<br>$$</p><p>然而遗憾的是这个哈密顿量很难解（why?），前人最有经验的问题是单粒子问题，于是，最暴力的近似方式是直接忽略电子与电子之间的相互作用。这样的近似下，可以通过分离变量法将多粒子问题转化为单粒子问题。但是，电子与电子之间的相互作用与电子与核的相互作用应该在一个档次（都是库伦相互作用，电荷量又差不多）。可想而知，这样做误差会很大。于是有人想到一种既可以分离变量，误差又没那么大的方法：中心力场近似。</p><h2 id="Central-field-approximation-中心力场近似"><a href="#Central-field-approximation-中心力场近似" class="headerlink" title="Central field approximation(中心力场近似)"></a>Central field approximation(中心力场近似)</h2><p>用一个中心对称的势能函数来近似其余电子对某个电子的作用。而且，每个电子体验到的势能函数都一样。由于原子核对电子的作用也是中心对称的，我们可以把二者合写为：$$U(r)$$，于是哈密顿量可以表示为：</p><p>$$<br>H =  \sum_{i=1}^N \left[ -\frac{1}{2} \nabla_i^2 + U(r_i) \right] + H_{res}<br>$$</p><p>其中$$H_{res}$$ 代表residual hamiltonian，是电子相互作用非中心对称部分，把它看做小量。如果先忽略$$H_{res}$$，那么对于的schrodinger方程就可以分离变量，转化为单粒子问题。只不过这里的$$U(r)$$ 与电子波函数有关，也就是说，我们要知道了电子的状态，才能得到 $$U$$。这种问题常用<a href="http://zh.wikipedia.org/wiki/%E8%87%AA%E6%B4%BD%E5%9C%BA%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">自洽场方法</a>处理(Self-Consistant Field method)。<br>我们可以用单粒子波函数构造体系的波函数：</p><p>\begin{equation}<br>| \Psi \rangle = |\psi_a(r_1,\chi_1)\rangle |\psi_b(r_2,\chi_2)\rangle |\psi_c(r_3,\chi_3)\rangle …<br>= \frac{1}{\sqrt{N!}}<br>\left[             %左括号<br>  \begin{array}{ccc}   %该矩阵一共3列，每一列都居中放置<br>    |\psi_a(r_1,\chi_1)\rangle  &amp; |\psi_b(r_1,\chi_1)\rangle  &amp; …\<br>    |\psi_a(r_2,\chi_2)\rangle  &amp; |\psi_b(r_2,\chi_2)\rangle  &amp; …\<br>    …                         &amp; …                         &amp; … \<br>  \end{array}<br>\right]<br>\end{equation}</p><p>\begin{equation}<br>\left[             %左括号<br>  \begin{array}{ccc}   %该矩阵一共3列，每一列都居中放置<br>    |\psi_a(r_1,\chi_1)\rangle  &amp; |\psi_b(r_1,\chi_1)\rangle  &amp; …\<br>    |\psi_a(r_2,\chi_2)\rangle  &amp; |\psi_b(r_2,\chi_2)\rangle  &amp; …\<br>    …                         &amp; …                         &amp; … \<br>  \end{array}<br>\right]<br>\end{equation}</p><p>其中的单粒子态是分离变量之后的的schrodidnger方程的解：</p><p>$$<br>\left[ -\frac{1}{2} \nabla^2 + U(r) \right] |\psi_i(r,\chi)\rangle = E_i |\psi_i(r,\chi)\rangle<br>$$</p><p>需要记住的是：所有电子都是一样的，所谓电子占据轨道只是一种形象化的说法。其本质是电子系统波函数需要满足反对称关系。<br>另外，由于$$U(r)$$ 是中心对称的，因此单粒子哈密顿量与角动量算对易，电子角动量守恒。因此电子的状态还是可以用 $$n, l, m_l$$来表示，与氢原子不同之处在于，能量不再只与 n 有关，还和l有关了。具体计算过程可以在<a href="">这里找到</a>。<br>计算结果可以用以下这个图片来表示：</p><p><center><img src="/public/blogfigure/2014-4-1.png"></center><br>在中心力场近似下，可以得到原子能级的分布图(Aufbau Principle)：</p><p><center><img src="/public/blogfigure/2014-4-1-energy.png"></center><br>从这幅图中我们可以看出，由于电子之间的相互作用，</p><p>$$<br>H =  -\frac{1}{2} \nabla^2 - \frac{1}{r}<br>$$</p><p>$$<br>H = \sum_{i=1}^N \left{ -0.5 \nabla_i^2 - \frac{Z}{r_i} \right. + \sum_{i&gt;j} \frac{1}{ r_{ij} } + H_{s-o}<br>$$</p><p>其中，$$H_{s-0}$$ 代表自旋轨道耦合作用。首先我们忽略自旋轨道耦合项（后面用微绕论加进来）。那么哈密顿量就变成：</p><ul><li>磁铁为什么有磁性？当然是因为构成磁铁的原子有磁性咯。那么原子的磁性又是怎么来的呢？学过原子物理的你可能已经知道，原子的基态磁矩可以根据 Hund 规则得到。本文的目的有二：一是从原子的Hamiltonian出发，告诉你 Hund 定则是怎么来的；二是告诉你如何利用 Hund 定则计算原子的磁矩。</li></ul><h2 id="Hund-规则及其限制"><a href="#Hund-规则及其限制" class="headerlink" title="Hund 规则及其限制"></a>Hund 规则及其限制</h2><p>Hund 总结了光谱数据得到了如</p><h2 id="从-Hund-规则计算原子磁矩"><a href="#从-Hund-规则计算原子磁矩" class="headerlink" title="从 Hund 规则计算原子磁矩"></a>从 Hund 规则计算原子磁矩</h2><h2 id="Hund-规则是怎么来的"><a href="#Hund-规则是怎么来的" class="headerlink" title="Hund 规则是怎么来的"></a>Hund 规则是怎么来的</h2><p>我们从原子的哈密顿量出发：</p><p>第一步近似：得到与氢原子类似的能级结构，形象地理解为电子占据能级，但其实所有电子完全一样。一个态最多有一个电子占据的原因是体系波函数的反对称要求决定。</p><p>第二步近似：剩下的静电势能。导致了</p><ul><li>我希望从哈密顿量出发，理解物质磁性的量子力学起源。麦克斯韦告诉我们，物质的磁性来自于磁矩，而磁矩来自于带电物体运动圆周运动（如果不是圆周运动会如何？）。物质由原子组成，原子由电子和原子核组成。在我们的故事中，做圆周运动的带电物体指的是电子。电子的轨道和自旋角动量，就是物质磁性的主要来源。要理解物质磁性的起源，我想，首先自然需要理解组成物质的原子的磁性咯。原子中的那么多电子，是如何在量子力学的指导下，为我们显现出这奇妙的磁性的呢？—–写得太糟糕，需要修改！</li></ul><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>]]></content>
      
      
      
        <tags>
            
            <tag> physics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决多体问题的二次量子化方法（专注费米子)</title>
      <link href="/2014/12/02/second_quantization/"/>
      <url>/2014/12/02/second_quantization/</url>
      
        <content type="html"><![CDATA[<blockquote><p>好不容易理解了什么是二次量子化，在此记录。理解本文的基础：</p><ul><li>普通量子力学</li><li>slater行列式构造多费米子波函数空间</li></ul></blockquote><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h1 id="What-and-Why"><a href="#What-and-Why" class="headerlink" title="What and Why"></a>What and Why</h1><ul><li><p>What is second quantization<br>二次量子化是一种数学技巧。建立在量子力学基本原理之上。</p></li><li><p>Why second quantize<br>使用未二次量子化的波函数和哈密顿量处理有相互作用的多体问题十分麻烦。所以想出了一种方法方便处理。</p></li></ul><h1 id="必要的定义以及多体系统态空间的建立"><a href="#必要的定义以及多体系统态空间的建立" class="headerlink" title="必要的定义以及多体系统态空间的建立"></a>必要的定义以及多体系统态空间的建立</h1><p>天下没有免费的午餐，为了要使用二次量子化工具，必须要先定义一些量。这些定义的目的是建立另一种形式的多体波函数以及哈密顿量。要始终记住的是：二次量子化的态和力学量算符与一次量子化的态和算符是等价的。</p><h2 id="一：定义真空态"><a href="#一：定义真空态" class="headerlink" title="一：定义真空态"></a>一：定义真空态</h2><p> $$|0&gt;$$  真空态满足：<br> \begin{equation}<br> &lt;0|0&gt; = 1<br> \end{equation}</p><h2 id="二：以某力学量为参考，定义产生，湮灭算符"><a href="#二：以某力学量为参考，定义产生，湮灭算符" class="headerlink" title="二：以某力学量为参考，定义产生，湮灭算符"></a>二：以某力学量为参考，定义产生，湮灭算符</h2><p>$$c_i^+, c_i$$用来产生湮灭粒子。</p><p>比如：选取动量算符为参考，那么，产生算符作用到真空态上（$$c_i^+|0&gt;$$）产生一个处于动量算符第i个本征态上的粒子。<br>性质：</p><p>$$c_i^+|0&gt; = |0…1…0&gt;  (例如：代表动量第i个本征态上占据一个电子)$$</p><p>$$c_i^+|0…1…0&gt; = 0$$</p><p>$$c_i|0…1…0&gt; = |0&gt;$$</p><p>$$c_i|0&gt; = 0$$</p><h2 id="三：定义产生湮灭算符的反对易关系："><a href="#三：定义产生湮灭算符的反对易关系：" class="headerlink" title="三：定义产生湮灭算符的反对易关系："></a>三：定义产生湮灭算符的反对易关系：</h2><p>$${c_i, c_j} = 0       for any i, j$$ </p><p>$${c_i^+, c_j^+} = 0        for any i, j$$</p><p>$${c_i^+, c_j} = \delta_{i,j} $$</p><h2 id="四：定义n粒子系统的基矢。"><a href="#四：定义n粒子系统的基矢。" class="headerlink" title="四：定义n粒子系统的基矢。"></a>四：定义n粒子系统的基矢。</h2><p>例如，在动量表象中：<br>n粒子基态为：$$c_1^+ c_2^+…c_n^+ \left|0\right\rangle$$。代表有n个粒子分别处于动量算符的第n, n-1, …, 1个本征态。</p><p>能量比基态稍高的态：$$ c_1^+ c_2^+ … c^+<em>{n-1} c^+</em>{n+1} \left|0\right\rangle $$。原本处于第n态的粒子激发到n+1态上了。</p><p>通过以上的定义，我们得到了系统的态空间（稍后你会发现，这与slater行列式等价）。</p><h1 id="二次量子化形式的哈密顿量"><a href="#二次量子化形式的哈密顿量" class="headerlink" title="二次量子化形式的哈密顿量"></a>二次量子化形式的哈密顿量</h1><h2 id="原先的哈密顿量（带相互作用）"><a href="#原先的哈密顿量（带相互作用）" class="headerlink" title="原先的哈密顿量（带相互作用）"></a>原先的哈密顿量（带相互作用）</h2><p>$$H = \sum_i H_1(x_i) + \frac{1}{2} \sum_{i \not = j} V_2(x_i - x_j)$$</p><p>其中$$H_1$$ 代表第i个单粒子能量，$$V_2(x_i - x_j)$$ 代表第i个粒子与第j个粒子之间的相互作用势能。</p><h2 id="二次量子化形式的哈密顿量-1"><a href="#二次量子化形式的哈密顿量-1" class="headerlink" title="二次量子化形式的哈密顿量"></a>二次量子化形式的哈密顿量</h2><p>$$H = \sum_i \epsilon_i c_i^+ c_i + \sum_{ijkl}V_{ij:lk} c_i^+ c_j^+c_kc_l$$</p><p>where</p><p>$$\epsilon_i = \int dx u_i^*(x)H_1(x)u_i(x)$$</p><p>and</p><p>$$V_{ij:lk} = \int dx \int dx’ u_i^<em>(x) u_j^</em>(x’) V_2(x-x’) u_k(x’) u_l(x)$$</p><p>$$u_i(x)$$代表某力学量算符（例如动量）的第i个本征函数。<br>可以发现该哈密顿量由三种东西构成：一次量子化形式的算符，算符的本征态以及产生湮灭算符。可以证明这个哈密顿量与原先的哈密顿量是等价的。<br>要证明二者等价，只需证明两个哈密顿量在各自态空间中矩阵元一致。<br>下面验证两种形式哈密顿量的对角元是一致的。</p><h1 id="验证两种量子化方法等价"><a href="#验证两种量子化方法等价" class="headerlink" title="验证两种量子化方法等价"></a>验证两种量子化方法等价</h1><h2 id="物理体系：两个相互作用的电子："><a href="#物理体系：两个相互作用的电子：" class="headerlink" title="物理体系：两个相互作用的电子："></a>物理体系：两个相互作用的电子：</h2><h3 id="一次量子化形式的哈密顿量"><a href="#一次量子化形式的哈密顿量" class="headerlink" title="一次量子化形式的哈密顿量"></a>一次量子化形式的哈密顿量</h3><p>易知，一次量子化形式的哈密顿量为：<br>$$H = -\frac{\hbar^2}{2m} \frac{\partial^2}{\partial x_1 ^2}- \frac{\hbar^2}{2m} \frac{\partial^2}{\partial x_1 ^2} - \frac{e^2}{4\pi \epsilon_0|x_1 - x_2|}$$</p><p>$$x_1, x_2$$ 分别指代粒子1和粒子2。<br>以动量算符的本征态为素材，利用slater行列式可以建立体系的态空间。这里验证基态下两种量子化方法的哈密顿量期望值相等。这就相当于验证了$$H$$在动量空间中矩阵形式的对角元素。<br>设两个费米子，分别处于动量算符的两个本征态：$$\phi_1, \phi_2$$，可以用slater行列式得到体系的一次量子化形式的态。</p><h3 id="一次量子化形式的态矢量"><a href="#一次量子化形式的态矢量" class="headerlink" title="一次量子化形式的态矢量"></a>一次量子化形式的态矢量</h3><p>$$|\psi&gt; = \frac{1}{\sqrt 2}[\phi_1(x_1) \phi_2(x_2) - \phi_1(x_2) \phi_2(x_1)]$$</p><h3 id="一次量子化形式的哈密顿量在该态下的期望"><a href="#一次量子化形式的哈密顿量在该态下的期望" class="headerlink" title="一次量子化形式的哈密顿量在该态下的期望"></a>一次量子化形式的哈密顿量在该态下的期望</h3><p>$$&lt;\psi| H| \psi&gt;$$</p><p>$$ = \frac{1}{2}\int dx_1 dx_2 [\phi_1^<em>(x_1) \phi_2^</em>(x_2) - \phi_1^<em>(x_2) \phi_2^</em>(x_1)] H [\phi_1(x_1) \phi_2(x_2) - \phi_1(x_2) \phi_2(x_1)]$$</p><p>$$= \frac{1}{2}(&lt;\phi_1(x_1)|P_1| \phi_1(x_1)&gt; + &lt;\phi_2(x_1)|P_1| \phi_2(x_1)&gt; + &lt;\phi_1(x_2)|P_2| \phi_1(x_2)&gt; + &lt;\phi_2(x_1)|P_2| \phi_2(x_2)&gt;) + \int dx_1 dx_2 [ |\phi_1(x_1)|^2|\phi_2(x_2)|^2V_2 - \phi_1^<em>(x_1)\phi_2(x_1)\phi_2^</em>(x_2)\phi_1(x_2)V_2]$$</p><p>$$= &lt;\phi_1|P|\phi_1&gt; + &lt;\phi_2|P|\phi_2&gt; + \int dx_1 dx_2 [ |\phi_1(x_1)|^2|\phi_2(x_2)|^2V_2 - \phi_1^<em>(x_1)\phi_2(x_1)\phi_2^</em>(x_2)\phi_1(x_2)V_2]$$</p><h3 id="二次量子化形式的哈密顿量-2"><a href="#二次量子化形式的哈密顿量-2" class="headerlink" title="二次量子化形式的哈密顿量"></a>二次量子化形式的哈密顿量</h3><p>由二次量子化哈密顿量的定义得：</p><p>$$H = &lt;\phi_1|P|\phi_1&gt;c_1^+c_1 + &lt;\phi_2|P|\phi_2&gt;c_2^+c_2  + V_{12:12}c_1^+c_2^+c_2c_1 + V_{12:21}c_1^+c_2^+c_1c_2 $$</p><p>由于当$$c_i^+ $$与$$c_i$$数目不相等时作用到态上结果为0，因此上式有许多项被忽略了。</p><h3 id="二次量子化形式的态矢量"><a href="#二次量子化形式的态矢量" class="headerlink" title="二次量子化形式的态矢量"></a>二次量子化形式的态矢量</h3><p>$$|\psi&gt; = c_1^+ c_2^+|0&gt;$$</p><p>and</p><p>$$&lt;\psi| = &lt;0|c_2c_1$$</p><h3 id="二次量子化形式的哈密顿量在该态下的期望"><a href="#二次量子化形式的哈密顿量在该态下的期望" class="headerlink" title="二次量子化形式的哈密顿量在该态下的期望"></a>二次量子化形式的哈密顿量在该态下的期望</h3><p>$$&lt;\psi|H|\psi&gt; = …$$<br>可以用产生湮灭算符的对易关系来得到，结果与一次量子化一样。你也试一试把。</p>]]></content>
      
      
      
        <tags>
            
            <tag> physics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo commands</title>
      <link href="/2014/03/05/hello-world/"/>
      <url>/2014/03/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="Try-to-preview-js"><a href="#Try-to-preview-js" class="headerlink" title="Try to preview js"></a>Try to preview js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> tech </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
